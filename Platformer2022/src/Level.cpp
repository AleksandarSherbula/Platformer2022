#include "Level.h"
#include "Game.h"

JsonTileData::JsonTileData()
{
}

bool JsonTileData::IsSolid()
{
	return colliders.size() > 0;
}

bool JsonTileData::IsFullBlock()
{
	if (IsSolid())
		return (colliders[0].width == 16 && colliders[0].height == 16);
	return false;
}

Tileset::Tileset()
{
}

Tileset::Tileset(const std::string& jsonFile)
{
	mJson = nlohmann::json::parse(ReadFromFile(jsonFile));
	int size = mJson["tiles"].size();	

	int solidTilesSize = 0;
	for (int i = 0; i < size; i++)
	{	
		int colSize = mJson["tiles"][i]["objectgroup"]["objects"].size();
		if (colSize > 0)
		{
			solidTilesSize++;
		}		
	}

	tileData.reserve(solidTilesSize);
	int st = 0;
	for (int i = 0; i < size; i++)
	{
		int colSize = mJson["tiles"][i]["objectgroup"]["objects"].size();
		
		if (colSize > 0)
		{
			tileData.push_back(JsonTileData());

			///////////// ID ///////////////////////
			tileData[st].id = mJson["tiles"][i]["id"];

			///////////// IS GROUND ///////////////////////
			for (int j = 0; j < mJson["tiles"][i]["properties"].size(); j++)
			{
				if (mJson["tiles"][i]["properties"][j]["name"] == "isGround")
				{
					tileData[st].isGround = mJson["tiles"][i]["properties"][j]["value"];
				}
			}

			///////////// COLLIDERS ///////////////////////
			int colSize = mJson["tiles"][i]["objectgroup"]["objects"].size();
			tileData[st].colliders.reserve(colSize);
			for (int j = 0; j < colSize; j++)
			{
				// Fix for an odd floating numbers generated by Tiled in json file
				float colX = mJson["tiles"][i]["objectgroup"]["objects"][j]["x"];
				float colY = mJson["tiles"][i]["objectgroup"]["objects"][j]["y"];

				float colXFract = colX - (int)colX;
				float colYFract = colY - (int)colY;

				if (colXFract > 0.9f) colX = (int)colX + 1;
				if (colYFract > 0.9) colY = (int)colY + 1;

				tileData[st].colliders.push_back({
					(int)colX,
					(int)colY,
					mJson["tiles"][i]["objectgroup"]["objects"][j]["width"],
					mJson["tiles"][i]["objectgroup"]["objects"][j]["height"]
					}
				);
			}

			st++;
		}		
	}
}

JsonTileData* Tileset::GetTileData(unsigned int id)
{
	for (int i = 0; i < tileData.size(); i++)
	{
		if (id == tileData[i].id)
			return &tileData[i];
	}

	return nullptr;
}

Tile::Tile(unsigned int id)
{
	this->id = id;

	unsigned int horizontalFlag = 0x80000000;
	unsigned int verticalFlag = 0x40000000;
	unsigned int diagonalFlag = 0x20000000;
	unsigned int rotatedFlag = 0x10000000;

	H_Flip = this->id & horizontalFlag;
	V_Flip = this->id & verticalFlag;
	D_Flip = this->id & diagonalFlag;
	R_Flip = this->id & rotatedFlag;

	this->id &= ~(horizontalFlag | verticalFlag |
		diagonalFlag | rotatedFlag);
	
}



/////////////////////////////LEVEL//////////////////////////////////////////////

Level::Level()
{
}

void Level::Load(const std::string& imageFile, const std::string& mapJsonFile, const std::string& tilesetJsonFile)
{
	spr.Load(imageFile);
	tileset = Tileset(tilesetJsonFile);

	mJson = nlohmann::json::parse(ReadFromFile(mapJsonFile));

	width = mJson["width"];
	height = mJson["height"];

	mData.reserve(width * height);
	for (int y = 0; y < height; y++)
		for (int x = 0; x < width; x++)
		{
			mData.push_back(Tile(mJson["layers"][0]["data"][y * width + x]));
			mData[y * width + x].pos.x = x;
			mData[y * width + x].pos.y = y;
		}
}

Tile* Level::GetTile(const olc::vi2d& pos)
{
	if (pos.x >= 0 && pos.x < width &&
		pos.y >= 0 && pos.y < height)
		return &mData[pos.y * width + pos.x];

	return nullptr;
}

Tile* Level::GetTile(int mapIndex)
{
	if (mapIndex >= 0 && mapIndex < mData.size())
		return &mData[mapIndex];

	std::cout << "Tile map index " << mapIndex << " not valid.\n";
	return nullptr;
}

void Level::Update(float fElapsedTime)
{
}

void Level::Draw()
{
	game->DrawDecal(olc::vf2d(-game->camera->offset.x, 0) * 16, spr.Decal());
}

void Level::DrawColliders()
{
	for (int x = 0; x < game->camera->viewPort.x + 1; x++)
	{
		for (int y = 0; y < game->camera->viewPort.y + 1; y++)
		{
			Tile* mapTile = game->level->GetTile(olc::vi2d(x, y) + game->camera->offset);
			if (mapTile != nullptr)
			{
				JsonTileData* tileData = tileset.GetTileData(mapTile->id - 1);
				if (tileData != nullptr && tileData->IsSolid())
				{
					for (int j = 0; j < tileData->colliders.size(); j++)
					{
						int colWidth = tileData->colliders[j].width;
						int colHeight = tileData->colliders[j].height;

						int colX, colY;

						if (mapTile->H_Flip && colWidth != 16)
							colX = (mapTile->pos.x * 16 + 15) - tileData->colliders[j].x;
						else
							colX = mapTile->pos.x * 16 + tileData->colliders[j].x;

						colY = mapTile->pos.y * 16 + tileData->colliders[j].y;

						olc::Pixel colColor;
						int i = (mapTile->pos.x) * game->level->width + (mapTile->pos.y);
						if (i % 2 == 0)
							colColor = olc::BLUE;
						else
							colColor = olc::DARK_BLUE;

						game->FillRectDecal(olc::vf2d(colX - game->camera->offset.x * 16, colY), olc::vi2d(colWidth, colHeight), colColor);
					}
				}
			}
			
		}
	}
};